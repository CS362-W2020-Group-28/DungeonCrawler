<!DOCTYPE HTML>
<html>
<head>

<style type="text/css">

body {
	width: 100%;
	height: 100%;
	margin: 0;
	background-color: black;
}

#canvas {
	position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
max-width: 100%;
max-height: 100%;
    margin: auto;
    background-color: white;
      image-rendering: pixelated;  



}




</style>



</head>

<body>
<canvas id="canvas" width="320" height="240"></canvas>

<div style="display:none;">
		<img id="chest" src="img/chest.png" />
		<img id="basicTiles" src="img/basictiles.png" />
		<img id="characters" src="img/characters.png" />
</div>
	
</body>

<script type="text/javascript" src="/scripts/jquery-3.1.1.min.js"></script>

<script type="text/javascript">

var input = {
		w: false,
		s: false,
		a: false,
		d: false
}


var width = 320;
var height = 240;
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var Scene;
var startTime = new Date();
var endTime = new Date();

var tileImage;


document.addEventListener('keydown',doKeyDown,false);
document.addEventListener('keyup',doKeyRelease,false);


$(function() {

	Scene = new Scene();
	tileImage = document.getElementById("basicTiles");


	Scene.Start();

	requestAnimationFrame(mainLoop);

});





//X & Y coordinates
function Vector2() {
	this.x = 0.0;
	this.y = 0.0;
}

function Transform() {
	this.position = new Vector2();
	this.rotation = new Vector2();
	this.scale = new Vector2();
}


function BoxCollider(width, height) {

	this.offset = new Vector2();

	this.width = width;
	this.height = height;

	this.checkCollision = function(scene, position) {


		/*

		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		*/
		

		//To-do: check for other box colliders

		for(var i = 0; i < scene.GameObjects.length; i++) {


			//Does the object have a box collider?
			if(scene.GameObjects[i].boxCollider) {

				if(scene.GameObjects[i].boxCollider != this) {


					if (position.x < scene.GameObjects[i].transform.position.x + scene.GameObjects[i].boxCollider.width &&
					   position.x + this.width > scene.GameObjects[i].transform.position.x &&
					   position.y < scene.GameObjects[i].transform.position.y + scene.GameObjects[i].boxCollider.height &&
					   this.height + position.y > scene.GameObjects[i].transform.position.y) {

						if(scene.GameObjects[i].onCollide) {
							scene.GameObjects[i].onCollide();

						}

						return true;
					}

					

					

				}





			}

		}

		return false;

	}


}


//These objects will be used later on.
function GameObject() {
	this.transform = new Transform();

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {


	}

}

function Key() {
	this.type = "Key";

}


function Enemy(x, y) {
	this.type = "Enemy";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x*16;
	this.transform.position.y = y*16;
	this.speed = getRandomArbitrary(0.0001, 0.0007);
	//this.img = document.getElementById("chest");




	this.onCollide = function() {
		

	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


		//Store previous values of X and Y (for collisions)
		var prevX = this.transform.position.x;
		var prevY = this.transform.position.y;


		
		this.transform.position.y = lerp2(this.transform.position.y, player.transform.position.y, scene.deltaTime*this.speed);

		
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.y = prevY;

		}


		


		
		this.transform.position.x = lerp2(this.transform.position.x, player.transform.position.x, scene.deltaTime*this.speed);


		
		
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.x = prevX;

		}
		
			

	


	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/

		/*
		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);
		*/

		ctx.fillStyle = "green";

		 ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);


	}


}

function StaticProp(buffer, x, y) {
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x;
	this.transform.position.y = y;

	this.offset = new Vector2();
	this.offset.x = 0;
	this.offset.y = -16;
	this.img = buffer;

	this.onCollide = function() {
		this.isOpen = 1;
	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


	}

	this.Draw = function(scene) {
		ctx.drawImage(this.img, 0, 0, 16, 16, Math.floor((this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x)),Math.floor((this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y)), 16, 16);


	}


}

function Chest(x, y) {
	this.type = "Chest";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x;
	this.transform.position.y = y;
	this.img = document.getElementById("chest");

	this.Inventory = [];

	this.isOpen = 0;

	this.onCollide = function() {
		this.isOpen = 1;

	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/


		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


	}


}

function Door(x, y) {
	this.type = "Door";

}


function Player() {
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = 64;
	this.transform.position.y = 64;

	this.speed = 0.1;

	this.health = 100;
	this.img = document.getElementById("characters");
	this.facing = 0; //0 - down; 1 - left; 2 - right; 3 - up
	this.frame = 0;


	this.onCollide = function(scene) {


	}

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {

		//console.log("Player position: (" + this.transform.position.x + ", " + this.transform.position.y + ")");
		//console.log("Player tile: (" + Math.floor(this.transform.position.x/16) + ", " + Math.floor(this.transform.position.y/16) + ")");

		scene.Camera.transform.position = lerp(scene.Camera.transform.position, this.transform.position, scene.deltaTime*0.001);

		//Store previous values of X and Y (for collisions)
		var prevX = this.transform.position.x;
		var prevY = this.transform.position.y;

		if(input.w || input.s || input.a || input.d) {

			this.frame += scene.deltaTime*0.01;
			this.frame = this.frame % 3;

		}


		if(input.w || input.s) {
			if(input.w) {
				this.transform.position.y -= (scene.deltaTime * this.speed);
				this.facing = 3; //Up



			}

			if(input.s) {
				this.transform.position.y += (scene.deltaTime * this.speed);
				this.facing = 0; //Down

			}

			/*

			// Check collisions based on current tile (Scene.tiles[y][x])
			if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)]) {
				if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)] == 2) {
				this.transform.position.y = prevY;

				}
			}
			*/


			
			if(this.boxCollider.checkCollision(scene, this.transform.position)) {
				this.transform.position.y = prevY;

			};
			


		}


		

		if(input.a || input.d) {
			if(input.a) {
				this.transform.position.x -= (scene.deltaTime * this.speed);
				this.facing = 1; //Left

			}

			if(input.d) {
				this.transform.position.x += (scene.deltaTime * this.speed);
				this.facing = 2; //Right

			}

			/*

			// Check collisions based on current tile (Scene.tiles[y][x])
			if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)]) {
				if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)] == 2) {
				this.transform.position.x = prevX;

				}

			}

			*/


			
			if(this.boxCollider.checkCollision(scene, this.transform.position)) {
				this.transform.position.x = prevX;

			};
			

			

		}

		

		




	}

	this.Draw = function(scene) {

		 ctx.fillStyle = "#000000";

		 //ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);

		 ctx.drawImage(this.img, 3*16 + (Math.floor(this.frame)*16), this.facing*16, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


		 //ctx.fillStyle = "red";


	}

}

function loadMapData(tileRenderer) {



	

}


function TileRenderer() {
	this.transform = new Transform();

	this.map = {};
	this.img = document.getElementById("basicTiles");

	this.tileBuffer = document.createElement('canvas');;

	this.tileContext = this.tileBuffer.getContext('2d');

	this.Start = function(scene) {

		this.tileBuffer = document.createElement('canvas');
		this.tileContext = this.tileBuffer.getContext('2d');
		this.img = document.getElementById("basicTiles");

		$.ajaxSetup({async: false});

		console.log("before map load");
		var mapData = {};

		$.get('/maps/testMap.json', function(data) {
			mapData = data;
			console.log("during map load");


		});

		console.log("after map load");

		this.map = mapData;

		this.tileBuffer.width = this.map.width * 16;
		this.tileBuffer.height = this.map.height * 16;

		for(var i = 0; i < this.map.layers.length; i++) {

				if(this.map.layers[i].type == "tilelayer") {

					for(var y = 0; y < this.map.height; y++) {

						for(var x = 0; x < this.map.width; x++) {

							var tileID = this.map.layers[i].data[x + this.map.width*y] - 1;

							var tX = tileID % 8;
							var tY = Math.floor(tileID / 8);

						    this.tileContext.drawImage(this.img, tX * 16, tY * 16, this.map.tilewidth, this.map.tileheight, x*16, y*16, this.map.tilewidth, this.map.tileheight);


						}

					}


				} else if(this.map.layers[i].type == "objectgroup") {
					for(var o = 0; o < this.map.layers[i].objects.length; o++) {

						var gID = this.map.layers[i].objects[o].gid - 1;

						var tX = gID % 8;
						var tY = Math.floor(gID / 8);

						var imgBuffer = document.createElement('canvas');
						var imgCtx = imgBuffer.getContext('2d');

						imgCtx.drawImage(this.img, tX * 16, tY * 16, 16, 16, 0, 0, 16, 16);


						scene.GameObjects.push(new StaticProp(imgBuffer, this.map.layers[i].objects[o].x, this.map.layers[i].objects[o].y));



					}


				}


			}



		/*
	
			$.get('/maps/testMap.json', function(data) {
				this.tileBuffer = document.createElement('canvas');
				this.tileContext = this.tileBuffer.getContext('2d');
				this.img = document.getElementById("basicTiles");

				this.map = data;


				this.tileBuffer.width = this.map.width * this.map.tilewidth;
			this.tileBuffer.height = this.map.height * this.map.tileheight;

			for(var i = 0; i < this.map.layers.length; i++) {

				if(this.map.layers[i].type == "tilelayer") {

					for(var y = 0; y < this.map.height; y++) {

						for(var x = 0; x < this.map.width; x++) {

							var tileID = this.map.layers[i].data[x + this.map.width*y] - 1;

							var tX = tileID % 8;
							var tY = tileID / 8;

						    this.tileContext.drawImage(this.img, tX * 16, tY * 16, this.map.tilewidth, this.map.tileheight, this.map.tilewidth, this.map.tileheight, this.map.tilewidth, this.map.tileheight);


						}

					}


				}


			}

			});
			*/


			

			


		


		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {
		


		ctx.drawImage(this.tileBuffer, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y + 16), this.map.width*this.map.tilewidth, this.map.height*this.map.tileheight);


		


	}



}



function Camera() {
	this.transform = new Transform();

	this.offset = new Vector2();

	this.offset.x = 320/2;
	this.offset.y = 240/2;

	this.Start = function(scene) {

		
	}


	this.Update = function(scene) {


	}

	this.Draw = function(scene) {



	}



}




function Scene() {
	this.GameObjects = [];
	this.deltaTime = 0.0;
	this.Camera = new Camera();

	

	this.Start = function() {


		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Start(this);

		}

	}

	this.Update = function() {

		this.Camera.Update(this);

		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Update(this);

		}

		

		this.deltaTime = new Date() - startTime;
		startTime = new Date();
	}

	this.Draw = function() {
		ctx.fillStyle = "#BBBBBB";
		ctx.fillRect(0, 0, width, height);


		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Draw(this);
		}

	}

	this.GameObjects.push(new TileRenderer());
	player = new Player();
	this.GameObjects.push(player);



}


function mainLoop() {

	Scene.Update();
	Scene.Draw();


	requestAnimationFrame(mainLoop);

}


function doKeyDown(e) {

			var code = e.keyCode;

			if (code == 87) { // w
				input.w = true;
			} else if(code == 83) { // s
				input.s = true;
			} else if(code == 65) { // a
				input.a = true;
			} else if(code == 68) { // d
				input.d = true;
			}
	}

	function doKeyRelease(e) {

		var code = e.keyCode;

			if (code == 87) { // w
				input.w = false;
			} else if(code == 83) { // s
				input.s = false;
			} else if(code == 65) { // a
				input.a = false;
			} else if(code == 68) { // d
				input.d = false;
			}



	}


	function lerp2(a,b,t) {

		//x axis
		var x = a + t * (b - a);

		return x;
	}

	//a and b are Vector2 objects
	function lerp(a,b,t) {

		//x axis
		var x = a.x + t * (b.x - a.x);

		//y axis
		var y = a.y + t * (b.y - a.y);

		var ret = new Vector2();
		ret.x = x;
		ret.y = y;

		return ret;

	}


	function getRandomArbitrary(min, max) {
  		return Math.random() * (max - min) + min;
	}



</script>


</html>
<!DOCTYPE HTML>
<html>
<head>
<style type="text/css">

body {
	width: 100%;
	height: 100%;
	margin: 0;
	background-color: black;
}

#canvas {
	position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100%;
    max-height: 100%;
    height: 100%;
    margin: auto;
    overflow: auto;
    background-color: white;


}


</style>


</head>

<body>
<canvas id="canvas" width="320" height="240"></canvas>

<div style="display:none;">
		<img id="chest" src="img/chest.png" />
</div>
	
</body>
<script type="text/javascript">

var input = {
		w: false,
		s: false,
		a: false,
		d: false,
    // New key implementations for attacking
    space: false,
    arrowKeyUp: false,
    arrowKeyDown: false,
    arrowKeyLeft: false,
    arrowKeyRight: false
}


var width = 320;
var height = 240;
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var Scene = new Scene();
var startTime = new Date();
var endTime = new Date();
var draw = true;

document.addEventListener('keydown',doKeyDown,false);
document.addEventListener('keyup',doKeyRelease,false);

var player;
//tile offest (tile size /2)
var tO = 8;


Scene.Start();

requestAnimationFrame(mainLoop);

//X & Y coordinates
function Vector2() {
	this.x = 0.0;
	this.y = 0.0;
}

function Transform() {
	this.position = new Vector2();
	this.rotation = new Vector2();
	this.scale = new Vector2();
}


function BoxCollider(width, height, parent, isTrigger) {
	this.parent  = parent;
	this.offset = new Vector2(); 
	this.trigger = isTrigger;
	this.width = width;
	this.height = height;

	this.checkCollision = function(scene, position) {



		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}


		/*

		//Top left
		if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x - this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x - this.width)/16)] == 2) {
					return true;

				}
		}


		//Top right
		if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}



		//Bottom left
		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x - this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x - this.width)/16)] == 2) {
					return true;

				}
		}


		//Bottom right
		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		*/

		//To-do: check for other box colliders

		for(var i = 0; i < scene.GameObjects.length; i++) {


			//Does the object have a box collider?
			if(scene.GameObjects[i].boxCollider) {

				if(scene.GameObjects[i].boxCollider != this) {


					if (position.x < scene.GameObjects[i].transform.position.x + scene.GameObjects[i].boxCollider.width &&
					   position.x + this.width > scene.GameObjects[i].transform.position.x &&
					   position.y < scene.GameObjects[i].transform.position.y + scene.GameObjects[i].boxCollider.height &&
					   this.height + position.y > scene.GameObjects[i].transform.position.y) {

						/*if(scene.GameObjects[i].onCollide) {
							scene.GameObjects[i].onCollide();

						}*/

						if(this.parent.onCollide) {
							this.parent.onCollide(scene.GameObjects[i]);
						}

						if(scene.GameObjects[i].boxCollider.trigger == true) {
							return false;
						}
						else return true;
					}

					

					

				}





			}

		}

		return false;

	}
}


//These objects will be used later on.
function GameObject() {
	this.transform = new Transform();

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {


	}

}

function Key() {
	this.type = "Key";

}


function Enemy(x, y) {
	this.type = "Enemy";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(15, 15, this, true);
	this.transform.position.x = x*16;
	this.transform.position.y = y*16;
	this.speed = getRandomArbitrary(0.07, 0.1);
    this.damage = 10;
	//this.img = document.getElementById("chest");
	this.path;
	var n = 0;
	this.playerPos = new Vector2();
	this.playerPos.x = player.transform.position.x+tO;
	this.playerPos.y = player.transform.position.y+tO;
    var prevX = this.transform.position.x;
    var prevY = this.transform.position.y;

    this.knockBack = false;
    this.kbtarget = new Vector2();

    this.refreshPath = function(scene) {
        this.playerPos.x = player.transform.position.x+tO;
        this.playerPos.y = player.transform.position.y+tO;
        this.path = createPath(this,player,scene);
                
        if(this.path.length < 2) {
            n = 0;
        } 
        else {
            n = 1;
        } 
    }

	this.Move = function(target,scene) {
		//Store previous values of X and Y (for collisions)
		prevX = this.transform.position.x;
		prevY = this.transform.position.y;
		if(Math.abs(this.transform.position.x - target.tile.x*16) < 0.5 && Math.abs(this.transform.position.y - target.tile.y*16) < 0.5) {
			this.transform.position.x = target.tile.x*16;
			this.transform.position.y = target.tile.y*16;

			if(Math.floor(this.playerPos.x/16) != Math.floor((player.transform.position.x+tO)/16) || Math.floor(this.playerPos.y/16) != Math.floor((player.transform.position.y+tO)/16)) {
				this.playerPos.x = player.transform.position.x+tO;
				this.playerPos.y = player.transform.position.y+tO;
				this.path = createPath(this,player,scene);
				
				if(this.path.length < 2) {
					n = 0;
				} 
				else {
					n = 1;
				} 
			}

			else if(n < this.path.length-1) {
				n++;
			}
			
		} 
		this.transform.position.x = lerp2(this.transform.position.x, target.tile.x*16, this.speed)
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.x = prevX;

		}
		this.transform.position.y = lerp2(this.transform.position.y, target.tile.y*16, this.speed)
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.y = prevY;

		}
	}

	this.onCollide = function(collider) {
		if(collider.type == "Attack") {
            if(!this.knockBack) {
                this.knockBack = true;
                this.kbtarget.x = this.transform.position.x - ((collider.boxPos.x - this.transform.position.x) * 2);
                this.kbtarget.y = this.transform.position.y - ((collider.boxPos.y - this.transform.position.y) * 2);
            }
            
        }
	}

	this.Start = function(scene) {
		this.path = createPath(this,player,scene);

	}

	this.Update = function(scene) {
		
        if(!this.knockBack) {
		  this.Move(this.path[n],scene);
        }
        else {
            this.transform.position.y = lerp2(this.transform.position.y, this.kbtarget.y, 0.1);
            if(this.boxCollider.checkCollision(scene, this.transform.position)) {
                this.transform.position.y = prevY;
                this.knockBack = false;
                this.refreshPath(Scene);
            }
            this.transform.position.x = lerp2(this.transform.position.x, this.kbtarget.x, 0.1);
            if(this.boxCollider.checkCollision(scene, this.transform.position)) {
                this.transform.position.x = prevX;
                this.knockBack = false;
                this.refreshPath(Scene);
            }

            if(Math.abs(this.transform.position.x - this.kbtarget.x) < 1 && Math.abs(this.transform.position.y - this.kbtarget.y) < 1) {
                this.knockBack = false;
                this.refreshPath(Scene);
            }
        }

	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/

		/*
		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);
		*/
        if(this.knockBack) {
            ctx.fillStyle = "red";
        }
		else  ctx.fillStyle = "green";

		 ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);


	}


}

function Chest(x, y) {
	this.type = "Chest";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16, this, false);
	this.transform.position.x = x*16;
	this.transform.position.y = y*16;
	this.img = document.getElementById("chest");

	this.Inventory = [];

	this.isOpen = 0;

	this.onCollide = function(collider) {
		this.isOpen = 1;

	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/


		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


	}


}

function Door(x, y) {
	this.type = "Door";

}

function Swing(dir,pos,damage) {
  this.type = "Attack";
  var tileSize = 16;
  this.boxCollider = new BoxCollider(16,16,this,true);
  this.boxPos = new Vector2();

  this.onCollide = function(collider) {
    if(collider.type == "Enemy") {
        console.log("attacked Enemy");
        collider.onCollide(this);
    }
  }

  if (dir == "up") {
    this.boxPos.x = pos.x;
    this.boxPos.y = pos.y - tileSize;
  }

  if (dir == "down") {
    this.boxPos.x = pos.x;
    this.boxPos.y = pos.y + tileSize;
  }
  
  if (dir == "left") {
    this.boxPos.x = pos.x - tileSize;
    this.boxPos.y = pos.y;
  }
  
  if (dir == "right") {
    this.boxPos.x = pos.x + tileSize;
    this.boxPos.y = pos.y;
  }

  if (dir == "up left") {
    this.boxPos.x = pos.x - tileSize;
    this.boxPos.y = pos.y - tileSize;
  }

  if (dir == "up right") {
    this.boxPos.x = pos.x + tileSize;
    this.boxPos.y = pos.y - tileSize;
  }
  
  if (dir == "down left") {
    this.boxPos.x = pos.x - tileSize;
    this.boxPos.y = pos.y + tileSize;
  }
  
  if (dir == "down right") {
    this.boxPos.x = pos.x + tileSize;
    this.boxPos.y = pos.y + tileSize;
  }

  this.boxCollider.checkCollision(Scene, this.boxPos);

  
  
}

function Player() {
	this.type = "Player";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16, this, true);
	this.transform.position.x = 64;
	this.transform.position.y = 64;
    this.knockBack = false;
    this.invuln = false;
    this.flash = false;
    this.flashing = false;
    this.dir = "left" 
    this.attacking = false;
    
    this.kbtarget = new Vector2();
	var prevX = this.transform.position.x;
	var prevY = this.transform.position.y;
    var invuln = this.invuln;

	this.speed = 0.1;

	this.health = 100;

    this.inventory = {
        "sword": true
    };


    // Collection of attacks?
    this.attack = function() {
      // Melee attack
      if (this.inventory["sword"]) {

      }
    }

	// TODO: Implement a die function
	this.die = function() {
        // Stops updating screen when player dies
        draw = false;

        ctx.fillStyle = "#000";

        ctx.fillRect(0,0,width,height);

        ctx.font = "26px sans-serif";
        ctx.fillStyle = "red";

        ctx.fillText("You dead",(width / 3),(height / 2));

	}

    this.resetInvuln = function() {
        player.invuln = false;
        console.log("resetInvuln");
    }
    this.setFlash = function() {
        if(player.flash) {
            player.flash = false;
        }
        else {player.flash = true;}
        if(player.invuln) {setTimeout(player.setFlash, 100);}
    }
    this.resetAttack = function() {
        player.attacking = false;
    }

	this.onCollide = function(collider) {
		if(collider.type == "Chest") {
			collider.isOpen = 1;
			console.log("Hit Chest");
		}
		if(collider.type == "Enemy") {
            if(!this.invuln) {
                if(!this.knockBack) {
                    console.log("Hit Enemy");
                    this.knockBack = true;
                    this.invuln = true;
                    // Invulnerability timer
                    setTimeout(this.resetInvuln, 1000);
                    this.health = this.health - collider.damage;
                    this.kbtarget.x = this.transform.position.x - ((collider.transform.position.x - this.transform.position.x) * 2);
                    this.kbtarget.y = this.transform.position.y - ((collider.transform.position.y - this.transform.position.y) * 2);
                }
			}
		}

	}

	this.Start = function(scene) {
        
		
	}

	this.Update = function(scene) {
        console.log(this.dir);
        //Store previous values of X and Y (for collisions)
        prevX = this.transform.position.x;
        prevY = this.transform.position.y;

        if(this.health <= 0) {
                this.die();
        }

        scene.Camera.transform.position = lerp(scene.Camera.transform.position, this.transform.position, scene.deltaTime*0.001);

        if(this.knockBack) {
            this.transform.position.y = lerp2(this.transform.position.y, this.kbtarget.y, this.speed);
            if(this.boxCollider.checkCollision(scene, this.transform.position)) {
                this.transform.position.y = prevY;
                this.knockBack = false;
            }
            this.transform.position.x = lerp2(this.transform.position.x, this.kbtarget.x, this.speed);
            if(this.boxCollider.checkCollision(scene, this.transform.position)) {
                this.transform.position.x = prevX;
                this.knockBack = false;
            }

            if(Math.abs(this.transform.position.x - this.kbtarget.x) < 1 && Math.abs(this.transform.position.y - this.kbtarget.y) < 1) {
                this.knockBack = false;
            }
        }

        else {
            
    		

    		if(input.w || input.s) {
    			if(input.w) {
            // this.dir = "up";
    				this.transform.position.y -= (scene.deltaTime * this.speed);
                }

    			if(input.s) {
            // this.dir = "down";
    				this.transform.position.y += (scene.deltaTime * this.speed);
    			}	
    		}

            if(this.boxCollider.checkCollision(scene, this.transform.position)) {
                    this.transform.position.y = prevY;

            };


    		

    		if(input.a || input.d) {
    			if(input.a) {
            // this.dir = "left";
    				this.transform.position.x -= (scene.deltaTime * this.speed);
    			}

    			if(input.d) {
            // this.dir = "right";
    				this.transform.position.x += (scene.deltaTime * this.speed);
    			}
    		}

            if(this.boxCollider.checkCollision(scene, this.transform.position)) {
                    this.transform.position.x = prevX;
            }

            // Checks 3 downward directions
            if(input.arrowKeyDown) {
              this.dir = "down";
            }

            // Checks 3 upward directions
            if(input.arrowKeyUp) {
              this.dir = "up";
            }

            if(input.arrowKeyRight) {
              this.dir = "right";
            }

            if(input.arrowKeyLeft) {
              this.dir = "left";
            }

            if(input.arrowKeyDown && input.arrowKeyLeft) {
              this.dir = "down left";
            }

            if(input.arrowKeyDown && input.arrowKeyRight) {
              this.dir = "down right";
            }

            if(input.arrowKeyUp && input.arrowKeyLeft) {
              this.dir = "up left";
            }

            if(input.arrowKeyUp && input.arrowKeyRight) {
              this.dir = "up right";
            }

            if(input.space) {
                if(!this.attacking) {
                    this.attacking = true;
                    setTimeout(this.resetAttack, 200);
                }
            }

            if(this.attacking) {
                swing = new Swing(this.dir, this.transform.position, 10);
            }
        }
	}

	this.Draw = function(scene) {
        if(this.knockBack) ctx.fillStyle = "red";
        else if(this.invuln) {
            if(!this.flashing) {
                this.flashing = true;
                this.flash = true;
                setTimeout(this.setFlash, 100);
            }
            
            if(this.flash) {
                ctx.fillStyle = "#D6D5D5";
            }
            else {
                ctx.fillStyle = "#000000";
            }
        }
        else {
            this.flashing = false;
            ctx.fillStyle = "#000000";
        }

		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
         
        ctx.fillStyle = "red";
        if(this.health <= 0) {
            //ctx.fillRect(10,10,0,10);
        } 
        else ctx.fillRect(10,10,this.health,10);

        if(this.attacking) {
            ctx.strokeStyle = "red"

            if (this.dir == "up") {
                ctx.strokeRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor((this.transform.position.y-16) - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }

              if (this.dir == "down") {
                ctx.strokeRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor((this.transform.position.y+16) - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }
              
              if (this.dir == "left") {
                ctx.strokeRect(Math.floor((this.transform.position.x-16) - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }
              
              if (this.dir == "right") {
                ctx.strokeRect(Math.floor((this.transform.position.x+16) - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }


              // 4 corner directional cases
              if (this.dir == "up left") {
                ctx.strokeRect(Math.floor((this.transform.position.x-16) - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor((this.transform.position.y-16) - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }

              if (this.dir == "up right") {
                ctx.strokeRect(Math.floor((this.transform.position.x+16) - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor((this.transform.position.y-16) - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }
              
              if (this.dir == "down left") {
                ctx.strokeRect(Math.floor((this.transform.position.x-16) - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor((this.transform.position.y+16) - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }
              
              if (this.dir == "down right") {
                ctx.strokeRect(Math.floor((this.transform.position.x+16) - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor((this.transform.position.y+16) - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);
              }
        }
	}

}


function TileRenderer() {
	this.transform = new Transform();
	

	this.Start = function(scene) {

		for(var i = 0; i < scene.tiles.length; i++) {

			for(var j = 0; j < scene.tiles[i].length; j++) {

				if(scene.tiles[j][i] == 1) {
					scene.tileContext.strokeStyle = "#CCCCCC"
					scene.tileContext.strokeRect(i*16,j*16,16,16);
				}

				if(scene.tiles[j][i] == 2) {
					scene.tileContext.fillRect(i*16,j*16,16,16);

				}

			}

		}


	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {
		ctx.drawImage(scene.tileBuffer, Math.floor(-scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(-scene.Camera.transform.position.y + scene.Camera.offset.y));
		


	}



}



function Camera() {
	this.transform = new Transform();

	this.offset = new Vector2();

	this.offset.x = 320/2;
	this.offset.y = 240/2;

	this.Start = function(scene) {

		
	}


	this.Update = function(scene) {


	}

	this.Draw = function(scene) {



	}



}




function Scene() {
	this.GameObjects = [];
	this.deltaTime = 0.0;
	this.Camera = new Camera();

	this.tiles = [[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]];

	this.tileBuffer = document.createElement('canvas');
	this.tileBuffer.width = 1024;
	this.tileBuffer.height = 1024;
	this.tileContext = this.tileBuffer.getContext('2d');

	this.Start = function() {
		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Start(this);

		}

	}

	this.Update = function() {

		this.Camera.Update(this);

		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Update(this);

		}

		

		this.deltaTime = new Date() - startTime;
		startTime = new Date();
	}

	this.Draw = function() {
    // Draws when draw is true
    if (draw) {
      ctx.fillStyle = "#BBBBBB";
      ctx.fillRect(0, 0, width, height);

      for(var i = 0; i < this.GameObjects.length; i++) {
        this.GameObjects[i].Draw(this);
      }
    }
	}

	this.GameObjects.push(new TileRenderer());
	player = new Player();
	this.GameObjects.push(player);

	this.GameObjects.push(new Chest(10,10));
	this.GameObjects.push(new Chest(12,10));
	enemy = new Enemy(9,4);
	this.GameObjects.push(enemy);
  //enemy = new Enemy(10,5);
  //this.GameObjects.push(enemy);
  //enemy = new Enemy(11,6);
  //his.GameObjects.push(enemy);
	
	




}


function mainLoop() {

	Scene.Update();
	Scene.Draw();


	requestAnimationFrame(mainLoop);

}

function Tile(x, y, cost) {
	this.getTile = function(n) {
		return Math.floor(n/16);
	}
	this.getCost = function(s, end) {
		this.g = this.parent.g + 1;
		this.h = Math.abs(end.tile.x - this.tile.x) + Math.abs(end.tile.y - this.tile.y)
		return this.g + this.h;
	}

	this.tile = new Vector2();
	this.tile.x = this.getTile(x);
	this.tile.y = this.getTile(y);
	this.parent;
	this.g = 0;
	this.h = 0;
	this.cost = cost;
}

function inList(t, cl) {
    for(var i = 0; i < cl.length; i++) {
        if(t.tile.x == cl[i].tile.x && t.tile.y == cl[i].tile.y) return true;
    }
    return false;
}

function findObjects(scene, type) {
    var objList = [];

    for (var i = 0; i < scene.GameObjects.length; i++) {
        if(Array.isArray(type)) {
            for(var j = 0; j < type.length; j++) {
                if(scene.GameObjects[i].type == type[j]) {
                    objList.push(new Tile(scene.GameObjects[i].transform.position.x, scene.GameObjects[i].transform.position.y, 0));
                }
            }
        }
        else {
            if(scene.GameObjects[i].type == type) {
            objList.push(new Tile(scene.GameObjects[i].transform.position.x, scene.GameObjects[i].transform.position.y, 0));
        }
        }
        
    }

    return objList;
}

function createPath(a , b, scene) {
	var map = new Array();
	map = scene.tiles;
	var openList = new Array();
	var closedList = new Array();
	var start = new Tile(a.transform.position.x,a.transform.position.y, 0);
	var curr = start;

	var target = new Tile(b.transform.position.x+tO, b.transform.position.y+tO);
	var tempTile = new Tile(0,0,0);
    var objList = findObjects(scene, ["Chest", "Enemy"]);
	this.addAdjTile = function(x,y) {
		if(map[y][x] == 1) {
			tempTile = new Tile(0,0,0);
			tempTile.tile.x = x;
			tempTile.tile.y = y;
			tempTile.parent = curr;
			tempTile.cost = tempTile.getCost(start,target);
			if(!inList(tempTile, closedList) && !inList(tempTile, objList)) {
				if(inList(tempTile, openList)) {
					var i = 0;
					for(i = 0; i < openList.length-1;i++) {
						if(tempTile.tile.x == openList[i].tile.x && tempTile.tile.y == openList[i].tile.y) {

						}
					}
				}
				else {
					openList.push(tempTile);
				} 
				
			} 
		}
	}

	do {
	//for(var ind = 0; ind < 7; ind++) {
		closedList.push(curr);
		//left tile
		this.addAdjTile(curr.tile.x-1,curr.tile.y);
		//right tile
		this.addAdjTile(curr.tile.x+1,curr.tile.y);
		//top tile
		this.addAdjTile(curr.tile.x,curr.tile.y-1);
		//bottom tile
		this.addAdjTile(curr.tile.x,curr.tile.y+1);
		tempTile = new Tile(0,0,0);
		var index = openList.length-1;
		tempTile = openList[index];
		for(var i = openList.length-1; i >= 0; i--) {
			if(openList[i].tile.x == target.tile.x && openList[i].tile.y == target.tile.y) {
				tempTile = openList[i];
				index = i;
				break;
			}
			else if(tempTile.cost > openList[i].cost) {
				tempTile = openList[i];
				index = i;
			}
		}
		openList.splice(index,1);
		curr = new Tile(0,0,0);
		curr = tempTile;
	} while((closedList[closedList.length-1].tile.x != target.tile.x || closedList[closedList.length-1].tile.y != target.tile.y) && curr != null);

	var list = new Array();
	var c = new Tile();
	var c = closedList[closedList.length-1];
	while (c != null) {
		list.push(c);
		c = new Tile();
		c = list[list.length-1].parent;
	}
	list.reverse();

	return list;
}


function doKeyDown(e) {

			var code = e.keyCode;
      console.log(e.keyCode);

			if (code == 87) { // w
				input.w = true;
			} else if(code == 83) { // s
				input.s = true;
			} else if(code == 65) { // a
				input.a = true;
			} else if(code == 68) { // d
				input.d = true;
			}
      else if(code == 32) { // spacebar
          input.space = true;
      }
      else if(code == 37) { // arrowKeyLeft
          input.arrowKeyLeft = true;
      }
      else if(code == 38) { // arrowKeyUp
          input.arrowKeyUp = true;
      }
      else if(code == 39) { // arrowKeyRight
          input.arrowKeyRight = true;
      }
      else if(code == 40) { // arrowKeyDown
          input.arrowKeyDown = true;
      }
	}

	function doKeyRelease(e) {

		var code = e.keyCode;

			if (code == 87) { // w
				input.w = false;
			} else if(code == 83) { // s
				input.s = false;
			} else if(code == 65) { // a
				input.a = false;
			} else if(code == 68) { // d
				input.d = false;
			} else if(code == 32) { // spacebar
                input.space = false;
      }
      else if(code == 37) { // arrowKeyLeft
          input.arrowKeyLeft = false;
      }
      else if(code == 38) { // arrowKeyUp
          input.arrowKeyUp = false;
      }
      else if(code == 39) { // arrowKeyRight
          input.arrowKeyRight = false;
      }
      else if(code == 40) { // arrowKeyDown
          input.arrowKeyDown = false;
      }




	}


	function lerp2(a,b,t) {

		//x axis
		var x = a + t * (b - a);

		return x;
	}

	//a and b are Vector2 objects
	function lerp(a,b,t) {

		//x axis
		var x = a.x + t * (b.x - a.x);

		//y axis
		var y = a.y + t * (b.y - a.y);

		var ret = new Vector2();
		ret.x = x;
		ret.y = y;

		return ret;

	}


	function getRandomArbitrary(min, max) {
  		return Math.random() * (max - min) + min;
	}



</script>


</html>
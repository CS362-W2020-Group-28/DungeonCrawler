<!DOCTYPE HTML>
<html>
<head>
<style type="text/css">

body {
	width: 100%;
	height: 100%;
	margin: 0;
	background-color: black;
}

#canvas {
	position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100%;
    max-height: 100%;
    height: 100%;
    margin: auto;
    overflow: auto;
    background-color: white;

}


</style>


</head>

<body>
<canvas id="canvas" width="320" height="240"></canvas>
	
</body>
<script type="text/javascript">

var input = {
		w: false,
		s: false,
		a: false,
		d: false
}


var width = 320;
var height = 240;
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var Scene = new Scene();
var startTime = new Date();
var endTime = new Date();

document.addEventListener('keydown',doKeyDown,false);
document.addEventListener('keyup',doKeyRelease,false);


Scene.Start();

requestAnimationFrame(mainLoop);

//X & Y coordinates
function Vector2() {
	this.x = 0.0;
	this.y = 0.0;
}

function Transform() {
	this.position = new Vector2();
	this.rotation = new Vector2();
	this.scale = new Vector2();
}


function BoxCollider(width, height) {

	this.offset = new Vector2();

	this.width = width;
	this.height = height;

	this.checkCollision = function(scene, position) {


		//Check for tile collisions first

		//Top left
		if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x - this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x - this.width)/16)] == 2) {
					return true;

				}
		}


		//Top right
		if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}



		//Bottom left
		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x - this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x - this.width)/16)] == 2) {
					return true;

				}
		}


		//Bottom right
		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}


		//To-do: check for other box colliders

		return false;

	}


}


//These objects will be used later on.
function GameObject() {
	this.transform = new Transform();

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {


	}

}


function Player() {
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(8, 8);
	this.transform.position.x = 64;
	this.transform.position.y = 64;

	this.speed = 0.1;

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {

		//console.log("Player position: (" + this.transform.position.x + ", " + this.transform.position.y + ")");
		//console.log("Player tile: (" + Math.floor(this.transform.position.x/16) + ", " + Math.floor(this.transform.position.y/16) + ")");

		scene.Camera.transform.position = lerp(scene.Camera.transform.position, this.transform.position, scene.deltaTime*0.001);

		//Store previous values of X and Y (for collisions)
		var prevX = this.transform.position.x;
		var prevY = this.transform.position.y;

		if(input.w || input.s) {
			if(input.w) {
				this.transform.position.y -= (scene.deltaTime * this.speed);

			}

			if(input.s) {
				this.transform.position.y += (scene.deltaTime * this.speed);

			}


			if(this.boxCollider.checkCollision(scene, this.transform.position)) {
				this.transform.position.y = prevY;

			};



		}


		

		if(input.a || input.d) {
			if(input.a) {
				this.transform.position.x -= (scene.deltaTime * this.speed);

			}

			if(input.d) {
				this.transform.position.x += (scene.deltaTime * this.speed);

			}


			if(this.boxCollider.checkCollision(scene, this.transform.position)) {
				this.transform.position.x = prevX;

			};

			

		}

		

		




	}

	this.Draw = function(scene) {

		 ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);


	}

}


function TileRenderer() {
	this.transform = new Transform();

	this.Start = function(scene) {

		for(var i = 0; i < scene.tiles.length; i++) {

			for(var j = 0; j < scene.tiles[i].length; j++) {

				if(scene.tiles[j][i] == 1) {
					scene.tileContext.strokeStyle = "#CCCCCC"
					scene.tileContext.strokeRect(i*16,j*16,16,16);
				}

				if(scene.tiles[j][i] == 2) {
					scene.tileContext.fillRect(i*16,j*16,16,16);

				}

			}

		}


	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {
		ctx.drawImage(scene.tileBuffer, Math.floor(-scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(-scene.Camera.transform.position.y + scene.Camera.offset.y));
		


	}



}



function Camera() {
	this.transform = new Transform();

	this.offset = new Vector2();

	this.offset.x = 320/2;
	this.offset.y = 240/2;

	this.Start = function(scene) {

		
	}


	this.Update = function(scene) {


	}

	this.Draw = function(scene) {



	}



}




function Scene() {
	this.GameObjects = [];
	this.deltaTime = 0.0;
	this.Camera = new Camera();

	this.tiles = [[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
				 ,[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2]
				 ,[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
				 ,[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]];

	this.tileBuffer = document.createElement('canvas');
	this.tileBuffer.width = 1024;
	this.tileBuffer.height = 1024;
	this.tileContext = this.tileBuffer.getContext('2d');

	this.Start = function() {
		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Start(this);

		}

	}

	this.Update = function() {

		this.Camera.Update(this);

		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Update(this);

		}

		

		this.deltaTime = new Date() - startTime;
		startTime = new Date();
	}

	this.Draw = function() {
		ctx.clearRect(0, 0, width, height);


		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Draw(this);
		}

	}

	this.GameObjects.push(new TileRenderer());
	this.GameObjects.push(new Player());


}


function mainLoop() {

	Scene.Update();
	Scene.Draw();


	requestAnimationFrame(mainLoop);

}


function doKeyDown(e) {

			var code = e.keyCode;

			if (code == 87) { // w
				input.w = true;
			} else if(code == 83) { // s
				input.s = true;
			} else if(code == 65) { // a
				input.a = true;
			} else if(code == 68) { // d
				input.d = true;
			}
	}

	function doKeyRelease(e) {

		var code = e.keyCode;

			if (code == 87) { // w
				input.w = false;
			} else if(code == 83) { // s
				input.s = false;
			} else if(code == 65) { // a
				input.a = false;
			} else if(code == 68) { // d
				input.d = false;
			}



	}

	//a and b are Vector2 objects
	function lerp(a,b,t) {

		//x axis
		var x = a.x + t * (b.x - a.x)

		//y axis
		var y = a.y + t * (b.y - a.y)

		var ret = new Vector2();
		ret.x = x;
		ret.y = y;

		return ret;

	}



</script>


</html>
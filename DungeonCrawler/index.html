<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:fb="http://ogp.me/ns/fb#">
<head>	
<title>Dungeon Crawler Engine Prototype</title>
<meta property="og:image" content="http://mrmatt.tv/dungeoncrawler/img/preview.png" />
<meta property="og:description"  content="2D graphics!" />

<style type="text/css">

body {
	width: 100%;
	height: 100%;
	margin: 0;
	background-color: black;
}

#canvas {
	position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    height: 100%;
	max-height: 100%;
    margin: auto;
    background-color: white;
      

}




</style>



</head>

<body>
<canvas id="canvas" width="320" height="240"></canvas>

<div style="display:none;">
		<img id="basicTiles" src="img/basictiles.png" />
		<img id="characters" src="img/characters.png" />
</div>
	
</body>

<script type="text/javascript" src="scripts/jquery-3.1.1.min.js"></script>

<script type="text/javascript">

var input = {
		w: false,
		s: false,
		a: false,
		d: false
}


var width = 320;
var height = 240;
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var Scene;
var startTime = new Date();
var endTime = new Date();

var tileImage;


document.addEventListener('keydown',doKeyDown,false);
document.addEventListener('keyup',doKeyRelease,false);


$(function() {

	Scene = new Scene();
	tileImage = document.getElementById("basicTiles");


	Scene.Start();

	requestAnimationFrame(mainLoop);

});





//X & Y coordinates
function Vector2() {
	this.x = 0.0;
	this.y = 0.0;
}

function Transform() {
	this.position = new Vector2();
	this.rotation = new Vector2();
	this.scale = new Vector2();
}


function BoxCollider(width, height) {

	this.offset = new Vector2();

	this.width = width;
	this.height = height;

	this.checkCollision = function(scene, position) {

		//Get tile id
		var tileID;

		for(var i = 0; i < scene.tileRenderer.map.layers.length; i++) {

			if(scene.tileRenderer.map.layers[i].type == "tilelayer") {
				tileID = scene.tileRenderer.map.layers[i].data[Math.floor(position.x/16) + scene.tileRenderer.map.width*Math.floor((position.y - 16)/16)] - 1;



				if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()]) {
					if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()].isSolid) {
						return true;


					}


				} 

				tileID = scene.tileRenderer.map.layers[i].data[Math.floor((position.x + this.width)/16) + scene.tileRenderer.map.width*Math.floor((position.y - 16)/16)] - 1;



				if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()]) {
					if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()].isSolid) {
						return true;


					}


				}

				tileID = scene.tileRenderer.map.layers[i].data[Math.floor((position.x + this.width)/16) + scene.tileRenderer.map.width*Math.floor((position.y + this.height - 16)/16)] - 1;



				if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()]) {
					if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()].isSolid) {
						return true;


					}


				}

				tileID = scene.tileRenderer.map.layers[i].data[Math.floor(position.x/16) + scene.tileRenderer.map.width*Math.floor((position.y + this.height - 16)/16)] - 1;



				if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()]) {
					if(scene.tileRenderer.map.tilesets[0].tileproperties[tileID.toString()].isSolid) {
						return true;


					}


				}



			}

		}
		








		/*

		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		*/
		

		//To-do: check for other box colliders

		for(var i = 0; i < scene.GameObjects.length; i++) {


			//Does the object have a box collider?
			if(scene.GameObjects[i].boxCollider) {

				if(scene.GameObjects[i].boxCollider != this) {


					if (position.x < scene.GameObjects[i].transform.position.x + scene.GameObjects[i].boxCollider.width &&
					   position.x + this.width > scene.GameObjects[i].transform.position.x &&
					   position.y < scene.GameObjects[i].transform.position.y + scene.GameObjects[i].boxCollider.height &&
					   this.height + position.y > scene.GameObjects[i].transform.position.y) {

						if(scene.GameObjects[i].onCollide) {
							return scene.GameObjects[i].onCollide(scene);

						}

						return true;
					}

					
				}





			}

		}

		return false;

	}


}


//These objects will be used later on.
function GameObject() {
	this.transform = new Transform();

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {


	}

}

function Key() {
	this.type = "Key";

}


function Enemy(x, y) {
	this.type = "Enemy";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(15, 15);
	this.transform.position.x = x*16;
	this.transform.position.y = y*16;
	this.speed = getRandomArbitrary(0.07, 0.1);
	//this.img = document.getElementById("chest");
	this.path;
	var n = 0;
	this.playerPos = new Vector2();
	this.playerPos.x = 0;
	this.playerPos.y = 0;

	this.Move = function(target,scene) {
		//Store previous values of X and Y (for collisions)
		var prevX = this.transform.position.x;
		var prevY = this.transform.position.y;
		if(Math.abs(this.transform.position.x - target.tile.x*16) < 0.5 && Math.abs(this.transform.position.y - target.tile.y*16) < 0.5) {
			this.transform.position.x = target.tile.x*16;
			this.transform.position.y = target.tile.y*16;

			if(Math.floor(this.playerPos.x/16) != Math.floor(player.transform.position.x/16) || Math.floor(this.playerPos.y/16) != Math.floor(player.transform.position.y/16)) {
				this.playerPos.x = scene.player.transform.position.x;
				this.playerPos.y = scene.player.transform.position.y;
				this.path = createPath(this,player,scene);
				if(this.path.length < 2) {
					n = 0;
				} 
				else {
					n = 1;
				} 
			}

			else if(n < this.path.length-1) {
				n++;
			}
			
		} 
		this.transform.position.x = lerp2(this.transform.position.x, target.tile.x*16, this.speed)
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.x = prevX;

		}
		this.transform.position.y = lerp2(this.transform.position.y, target.tile.y*16, this.speed)
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.y = prevY;

		}
	}

	this.onCollide = function() {
		

	}

	this.Start = function(scene) {
		this.path = createPath(this,player,scene);

	}

	this.Update = function(scene) {
		

		this.Move(this.path[n],scene);

	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/

		/*
		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);
		*/

		ctx.fillStyle = "green";

		 ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);


	}


}

function StaticProp(buffer, x, y) {
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x;
	this.transform.position.y = y;

	this.offset = new Vector2();
	this.offset.x = 0;
	this.offset.y = -16;
	this.img = buffer;

	this.onCollide = function(scene) {

		return true;
	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


	}

	this.Draw = function(scene) {
		ctx.drawImage(this.img, 0, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


	}


}

function Chest(x, y) {
	this.type = "Chest";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x;
	this.transform.position.y = y;
	this.img = document.getElementById("chest");

	this.Inventory = [];

	this.isOpen = 0;

	this.onCollide = function() {
		this.isOpen = 1;

	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/


		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


	}


}

function Door(x, y) {
	this.type = "Door";

}


function Player() {
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(14, 14);
	this.transform.position.x = 80;
	this.transform.position.y = 88;

	this.speed = 0.1;

	this.health = 100;
	this.img = document.getElementById("characters");
	this.facing = 0; //0 - down; 1 - left; 2 - right; 3 - up
	this.frame = 0;

	this.prevX = 0;
	this.prevY = 0;

	this.setPosition = function(x, y) {
		this.transform.position.x = x;
		this.transform.position.y = y;
		this.prevX = x;
		this.prevY = y;



	}


	this.onCollide = function(scene) {


	}

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {

		//console.log("Player position: (" + this.transform.position.x + ", " + this.transform.position.y + ")");
		//console.log("Player tile: (" + Math.floor(this.transform.position.x/16) + ", " + Math.floor(this.transform.position.y/16) + ")");

		scene.Camera.transform.position = lerp(scene.Camera.transform.position, this.transform.position, scene.deltaTime*0.004);

		//Store previous values of X and Y (for collisions)
		this.prevX = this.transform.position.x;
		this.prevY = this.transform.position.y;

		if(input.w || input.s || input.a || input.d) {

			this.frame += scene.deltaTime*0.01;
			this.frame = this.frame % 3;

		}


		if(input.w || input.s) {
			if(input.w) {
				this.transform.position.y -= (scene.deltaTime * this.speed);
				this.facing = 3; //Up



			}

			if(input.s) {
				this.transform.position.y += (scene.deltaTime * this.speed);
				this.facing = 0; //Down

			}

			/*

			// Check collisions based on current tile (Scene.tiles[y][x])
			if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)]) {
				if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)] == 2) {
				this.transform.position.y = prevY;

				}
			}
			*/


			
			if(!this.boxCollider.checkCollision(scene, this.transform.position)) {

			} else {
				this.transform.position.y = this.prevY;

			}
			


		}


		

		if(input.a || input.d) {
			if(input.a) {
				this.transform.position.x -= (scene.deltaTime * this.speed);
				this.facing = 1; //Left

			}

			if(input.d) {
				this.transform.position.x += (scene.deltaTime * this.speed);
				this.facing = 2; //Right

			}

			/*

			// Check collisions based on current tile (Scene.tiles[y][x])
			if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)]) {
				if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)] == 2) {
				this.transform.position.x = prevX;

				}

			}

			*/


			
			if(!this.boxCollider.checkCollision(scene, this.transform.position)) {

			} else {
				this.transform.position.x = this.prevX;


			}
			

			

		}

		

		




	}

	this.Draw = function(scene) {

		 ctx.fillStyle = "#000000";

		 //ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);

		 ctx.drawImage(this.img, 3*16 + (Math.floor(this.frame)*16), this.facing*16, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


		 //ctx.fillStyle = "red";


	}

}


function TileRenderer() {
	this.transform = new Transform();

	this.map = {};
	this.img = document.getElementById("basicTiles");

	this.tileBuffer = document.createElement('canvas');;

	this.tileContext = this.tileBuffer.getContext('2d');

	this.Start = function(scene) {

		this.tileBuffer = document.createElement('canvas');
		this.tileContext = this.tileBuffer.getContext('2d');
		this.img = document.getElementById("basicTiles");

		$.ajaxSetup({async: false});

		console.log("before map load");
		var mapData = {};

		$.get('maps/testMap.json', function(data) {
			mapData = data;
			console.log("during map load");


		});

		console.log("after map load");

		this.map = mapData;

		this.tileBuffer.width = this.map.width * 16;
		this.tileBuffer.height = this.map.height * 16;

		for(var i = 0; i < this.map.layers.length; i++) {

				if(this.map.layers[i].type == "tilelayer") {

					for(var y = 0; y < this.map.height; y++) {

						for(var x = 0; x < this.map.width; x++) {

							var tileID = this.map.layers[i].data[x + this.map.width*y] - 1;

							var tX = tileID % 8;
							var tY = Math.floor(tileID / 8);

						    this.tileContext.drawImage(this.img, tX * 16, tY * 16, this.map.tilewidth, this.map.tileheight, x*16, y*16, this.map.tilewidth, this.map.tileheight);


						}

					}


				} else if(this.map.layers[i].type == "objectgroup") {
					for(var o = 0; o < this.map.layers[i].objects.length; o++) {

						var gID = this.map.layers[i].objects[o].gid - 1;

						var tX = gID % 8;
						var tY = Math.floor(gID / 8);

						var imgBuffer = document.createElement('canvas');
						var imgCtx = imgBuffer.getContext('2d');

						imgCtx.drawImage(this.img, tX * 16, tY * 16, 16, 16, 0, 0, 16, 16);

						var prop = new StaticProp(imgBuffer, this.map.layers[i].objects[o].x, this.map.layers[i].objects[o].y);

						if(this.map.layers[i].objects[o].properties) {
							if(this.map.layers[i].objects[o].properties.onCollide) {
								prop.onCollide = new Function("scene", this.map.layers[i].objects[o].properties.onCollide + "return true;");


							}



						}

						scene.GameObjects.push(prop);



					}


				}


			}



		/*
	
			$.get('/maps/testMap.json', function(data) {
				this.tileBuffer = document.createElement('canvas');
				this.tileContext = this.tileBuffer.getContext('2d');
				this.img = document.getElementById("basicTiles");

				this.map = data;


				this.tileBuffer.width = this.map.width * this.map.tilewidth;
			this.tileBuffer.height = this.map.height * this.map.tileheight;

			for(var i = 0; i < this.map.layers.length; i++) {

				if(this.map.layers[i].type == "tilelayer") {

					for(var y = 0; y < this.map.height; y++) {

						for(var x = 0; x < this.map.width; x++) {

							var tileID = this.map.layers[i].data[x + this.map.width*y] - 1;

							var tX = tileID % 8;
							var tY = tileID / 8;

						    this.tileContext.drawImage(this.img, tX * 16, tY * 16, this.map.tilewidth, this.map.tileheight, this.map.tilewidth, this.map.tileheight, this.map.tilewidth, this.map.tileheight);


						}

					}


				}


			}

			});
			*/


			

			


		


		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {
		


		ctx.drawImage(this.tileBuffer, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y + 16), this.map.width*this.map.tilewidth, this.map.height*this.map.tileheight);


		


	}



}



function Camera() {
	this.transform = new Transform();

	this.offset = new Vector2();

	this.offset.x = 320/2;
	this.offset.y = 240/2;

	this.Start = function(scene) {

		
	}


	this.Update = function(scene) {


	}

	this.Draw = function(scene) {



	}



}




function Scene() {
	this.GameObjects = [];
	this.deltaTime = 0.0;
	this.Camera = new Camera();

	this.tileBuffer = document.createElement('canvas');
	this.tileBuffer.width = 1024;
	this.tileBuffer.height = 1024;
	this.tileContext = this.tileBuffer.getContext('2d');

	this.tileRenderer = new TileRenderer();
	this.player = new Player();

	this.Start = function() {


		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Start(this);

		}

	}

	this.Update = function() {

		this.Camera.Update(this);

		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Update(this);

		}

		

		this.deltaTime = new Date() - startTime;
		startTime = new Date();
	}

	this.Draw = function() {
		ctx.fillStyle = "#000000";
		ctx.fillRect(0, 0, width, height);


		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Draw(this);
		}

	}

	this.GameObjects.push(this.tileRenderer);
	this.player = new Player();
	this.GameObjects.push(this.player);


}


function mainLoop() {

	Scene.Update();
	Scene.Draw();


	requestAnimationFrame(mainLoop);

}

function Tile(x, y, cost) {
	this.getTile = function(n) {
		return Math.floor(n/16);
	}
	this.getCost = function(s, end) {
		this.g = this.parent.g + 1;
		this.h = Math.abs(end.tile.x - this.tile.x) + Math.abs(end.tile.y - this.tile.y)
		return this.g + this.h;
	}

	this.tile = new Vector2();
	this.tile.x = this.getTile(x);
	this.tile.y = this.getTile(y);
	this.parent;
	this.g = 0;
	this.h = 0;
	this.cost = cost;
}

function inList(t, cl) {
    for(var i = 0; i < cl.length; i++) {
        if(t.tile.x == cl[i].tile.x && t.tile.y == cl[i].tile.y) return true;
    }
    return false;
}

function findObjects(scene, type) {
    var objList = [];

    for (var i = 0; i < scene.GameObjects.length; i++) {
        if(Array.isArray(type)) {
            for(var j = 0; j < type.length; j++) {
                if(scene.GameObjects[i].type == type[j]) {
                    objList.push(new Tile(scene.GameObjects[i].transform.position.x, scene.GameObjects[i].transform.position.y, 0));
                }
            }
        }
        else {
            if(scene.GameObjects[i].type == type) {
            objList.push(new Tile(scene.GameObjects[i].transform.position.x, scene.GameObjects[i].transform.position.y, 0));
        }
        }
        
    }

    return objList;
}

function createPath(a , b, scene) {
	var map = new Array();
	map = scene.tiles;
	var openList = new Array();
	var closedList = new Array();
	var start = new Tile(a.transform.position.x,a.transform.position.y, 0);
	var curr = start;

	var target = new Tile(b.transform.position.x, b.transform.position.y);
	var tempTile = new Tile(0,0,0);
    var objList = findObjects(scene, ["Chest", "Enemy"]);
	this.addAdjTile = function(x,y) {
		if(map[y][x] == 1) {
			tempTile = new Tile(0,0,0);
			tempTile.tile.x = x;
			tempTile.tile.y = y;
			tempTile.parent = curr;
			tempTile.cost = tempTile.getCost(start,target);
			if(!inList(tempTile, closedList) && !inList(tempTile, objList)) {
				if(inList(tempTile, openList)) {
					var i = 0;
					for(i = 0; i < openList.length-1;i++) {
						if(tempTile.tile.x == openList[i].tile.x && tempTile.tile.y == openList[i].tile.y) {

						}
					}
				}
				else {
					openList.push(tempTile);
				} 
				
			} 
		}
	}

	do {
	//for(var ind = 0; ind < 7; ind++) {
		closedList.push(curr);
		//left tile
		this.addAdjTile(curr.tile.x-1,curr.tile.y);
		//right tile
		this.addAdjTile(curr.tile.x+1,curr.tile.y);
		//top tile
		this.addAdjTile(curr.tile.x,curr.tile.y-1);
		//bottom tile
		this.addAdjTile(curr.tile.x,curr.tile.y+1);
		tempTile = new Tile(0,0,0);
		var index = openList.length-1;
		tempTile = openList[index];
		for(var i = openList.length-1; i >= 0; i--) {
			if(openList[i].tile.x == target.tile.x && openList[i].tile.y == target.tile.y) {
				tempTile = openList[i];
				index = i;
				break;
			}
			else if(tempTile.cost > openList[i].cost) {
				tempTile = openList[i];
				index = i;
			}
		}
		openList.splice(index,1);
		curr = new Tile(0,0,0);
		curr = tempTile;
	} while((closedList[closedList.length-1].tile.x != target.tile.x || closedList[closedList.length-1].tile.y != target.tile.y) && curr != null);

	var list = new Array();
	var c = new Tile();
	var c = closedList[closedList.length-1];
	while (c != null) {
		list.push(c);
		c = new Tile();
		c = list[list.length-1].parent;
	}
	list.reverse();

	return list;
}


function doKeyDown(e) {

			var code = e.keyCode;

			if (code == 87) { // w
				input.w = true;
			} else if(code == 83) { // s
				input.s = true;
			} else if(code == 65) { // a
				input.a = true;
			} else if(code == 68) { // d
				input.d = true;
			}
	}

	function doKeyRelease(e) {

		var code = e.keyCode;

			if (code == 87) { // w
				input.w = false;
			} else if(code == 83) { // s
				input.s = false;
			} else if(code == 65) { // a
				input.a = false;
			} else if(code == 68) { // d
				input.d = false;
			}



	}


	function lerp2(a,b,t) {

		//x axis
		var x = a + t * (b - a);

		return x;
	}

	//a and b are Vector2 objects
	function lerp(a,b,t) {

		//x axis
		var x = a.x + t * (b.x - a.x);

		//y axis
		var y = a.y + t * (b.y - a.y);

		var ret = new Vector2();
		ret.x = x;
		ret.y = y;

		return ret;

	}


	function getRandomArbitrary(min, max) {
  		return Math.random() * (max - min) + min;
	}



</script>


</html>
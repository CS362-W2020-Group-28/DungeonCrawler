<!DOCTYPE HTML>
<html>
<head>
<style type="text/css">

body {
	width: 100%;
	height: 100%;
	margin: 0;
	background-color: black;
}

#canvas {
	position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100%;
    max-height: 100%;
    height: 100%;
    margin: auto;
    overflow: auto;
    background-color: white;


}


</style>


</head>

<body>
<canvas id="canvas" width="320" height="240"></canvas>

<div style="display:none;">
		<img id="chest" src="img/chest.png" />
</div>
	
</body>
<script type="text/javascript">

var input = {
		w: false,
		s: false,
		a: false,
		d: false
}


var width = 320;
var height = 240;
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var Scene = new Scene();
var startTime = new Date();
var endTime = new Date();

document.addEventListener('keydown',doKeyDown,false);
document.addEventListener('keyup',doKeyRelease,false);

var player;


Scene.Start();

requestAnimationFrame(mainLoop);

//X & Y coordinates
function Vector2() {
	this.x = 0.0;
	this.y = 0.0;
}

function Transform() {
	this.position = new Vector2();
	this.rotation = new Vector2();
	this.scale = new Vector2();
}


function BoxCollider(width, height) {

	this.offset = new Vector2();

	this.width = width;
	this.height = height;

	this.checkCollision = function(scene, position) {



		if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)]) {
				if(Scene.tiles[Math.floor((position.y)/16)][Math.floor((position.x)/16)] == 2) {
					return true;

				}
		}

		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}


		/*

		//Top left
		if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x - this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x - this.width)/16)] == 2) {
					return true;

				}
		}


		//Top right
		if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y - this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}



		//Bottom left
		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x - this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x - this.width)/16)] == 2) {
					return true;

				}
		}


		//Bottom right
		if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)]) {
				if(Scene.tiles[Math.floor((position.y + this.height)/16)][Math.floor((position.x + this.width)/16)] == 2) {
					return true;

				}
		}

		*/


		//To-do: check for other box colliders

		for(var i = 0; i < scene.GameObjects.length; i++) {


			//Does the object have a box collider?
			if(scene.GameObjects[i].boxCollider) {

				if(scene.GameObjects[i].boxCollider != this) {


					if (position.x < scene.GameObjects[i].transform.position.x + scene.GameObjects[i].boxCollider.width &&
					   position.x + this.width > scene.GameObjects[i].transform.position.x &&
					   position.y < scene.GameObjects[i].transform.position.y + scene.GameObjects[i].boxCollider.height &&
					   this.height + position.y > scene.GameObjects[i].transform.position.y) {

						if(scene.GameObjects[i].onCollide) {
							scene.GameObjects[i].onCollide();

						}

						return true;
					}

					

					

				}





			}

		}

		return false;

	}


}


//These objects will be used later on.
function GameObject() {
	this.transform = new Transform();

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {


	}

}

function Key() {
	this.type = "Key";

}


function Enemy(x, y) {
	this.type = "Enemy";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x*16;
	this.transform.position.y = y*16;
	this.speed = getRandomArbitrary(0.0001, 0.0007);
	//this.img = document.getElementById("chest");




	this.onCollide = function() {
		

	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


		//Store previous values of X and Y (for collisions)
		var prevX = this.transform.position.x;
		var prevY = this.transform.position.y;


		
		this.transform.position.y = lerp2(this.transform.position.y, player.transform.position.y, scene.deltaTime*this.speed);

		
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.y = prevY;

		}


		


		
		this.transform.position.x = lerp2(this.transform.position.x, player.transform.position.x, scene.deltaTime*this.speed);


		
		
		if(this.boxCollider.checkCollision(scene, this.transform.position)) {
			this.transform.position.x = prevX;

		}
		
			

	


	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/

		/*
		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);
		*/

		ctx.fillStyle = "green";

		 ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);


	}


}

function Chest(x, y) {
	this.type = "Chest";
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = x*16;
	this.transform.position.y = y*16;
	this.img = document.getElementById("chest");

	this.Inventory = [];

	this.isOpen = 0;

	this.onCollide = function() {
		this.isOpen = 1;

	}

	this.Start = function(scene) {


	}

	this.Update = function(scene) {


	}

	this.Draw = function(scene) {


		/*
		ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x - (16/2)),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y - (16/2)),16,16);
		*/


		ctx.drawImage(this.img, this.isOpen * 16, 0, 16, 16, Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y), 16, 16);


	}


}

function Door(x, y) {
	this.type = "Door";

}


function Player() {
	this.transform = new Transform();
	this.boxCollider = new BoxCollider(16, 16);
	this.transform.position.x = 64;
	this.transform.position.y = 64;

	this.speed = 0.1;

	this.health = 100;

	this.onCollide = function(scene) {


	}

	this.Start = function(scene) {

		
	}

	this.Update = function(scene) {

		//console.log("Player position: (" + this.transform.position.x + ", " + this.transform.position.y + ")");
		//console.log("Player tile: (" + Math.floor(this.transform.position.x/16) + ", " + Math.floor(this.transform.position.y/16) + ")");

		scene.Camera.transform.position = lerp(scene.Camera.transform.position, this.transform.position, scene.deltaTime*0.001);

		//Store previous values of X and Y (for collisions)
		var prevX = this.transform.position.x;
		var prevY = this.transform.position.y;

		if(input.w || input.s) {
			if(input.w) {
				this.transform.position.y -= (scene.deltaTime * this.speed);

			}

			if(input.s) {
				this.transform.position.y += (scene.deltaTime * this.speed);

			}

			/*

			// Check collisions based on current tile (Scene.tiles[y][x])
			if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)]) {
				if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)] == 2) {
				this.transform.position.y = prevY;

				}
			}
			*/


			
			if(this.boxCollider.checkCollision(scene, this.transform.position)) {
				this.transform.position.y = prevY;

			};
			


		}


		

		if(input.a || input.d) {
			if(input.a) {
				this.transform.position.x -= (scene.deltaTime * this.speed);

			}

			if(input.d) {
				this.transform.position.x += (scene.deltaTime * this.speed);

			}

			/*

			// Check collisions based on current tile (Scene.tiles[y][x])
			if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)]) {
				if(Scene.tiles[Math.floor(this.transform.position.y/16)][Math.floor(this.transform.position.x/16)] == 2) {
				this.transform.position.x = prevX;

				}

			}

			*/


			
			if(this.boxCollider.checkCollision(scene, this.transform.position)) {
				this.transform.position.x = prevX;

			};
			

			

		}

		

		




	}

	this.Draw = function(scene) {

		 ctx.fillStyle = "#000000";

		 ctx.fillRect(Math.floor(this.transform.position.x - scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(this.transform.position.y - scene.Camera.transform.position.y + scene.Camera.offset.y),16,16);


		 //ctx.fillStyle = "red";


	}

}


function TileRenderer() {
	this.transform = new Transform();
	

	this.Start = function(scene) {

		for(var i = 0; i < scene.tiles.length; i++) {

			for(var j = 0; j < scene.tiles[i].length; j++) {

				if(scene.tiles[j][i] == 1) {
					scene.tileContext.strokeStyle = "#CCCCCC"
					scene.tileContext.strokeRect(i*16,j*16,16,16);
				}

				if(scene.tiles[j][i] == 2) {
					scene.tileContext.fillRect(i*16,j*16,16,16);

				}

			}

		}


	}

	this.Update = function(scene) {



	}

	this.Draw = function(scene) {
		ctx.drawImage(scene.tileBuffer, Math.floor(-scene.Camera.transform.position.x + scene.Camera.offset.x),Math.floor(-scene.Camera.transform.position.y + scene.Camera.offset.y));
		


	}



}



function Camera() {
	this.transform = new Transform();

	this.offset = new Vector2();

	this.offset.x = 320/2;
	this.offset.y = 240/2;

	this.Start = function(scene) {

		
	}


	this.Update = function(scene) {


	}

	this.Draw = function(scene) {



	}



}




function Scene() {
	this.GameObjects = [];
	this.deltaTime = 0.0;
	this.Camera = new Camera();

	this.tiles = [[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
				 ,[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]];

	this.tileBuffer = document.createElement('canvas');
	this.tileBuffer.width = 1024;
	this.tileBuffer.height = 1024;
	this.tileContext = this.tileBuffer.getContext('2d');

	this.Start = function() {
		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Start(this);

		}

	}

	this.Update = function() {

		this.Camera.Update(this);

		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Update(this);

		}

		

		this.deltaTime = new Date() - startTime;
		startTime = new Date();
	}

	this.Draw = function() {
		ctx.fillStyle = "#BBBBBB";
		ctx.fillRect(0, 0, width, height);


		for(var i = 0; i < this.GameObjects.length; i++) {
			this.GameObjects[i].Draw(this);
		}

	}

	this.GameObjects.push(new TileRenderer());
	player = new Player();
	this.GameObjects.push(player);

	this.GameObjects.push(new Chest(10,10));
	this.GameObjects.push(new Chest(12,10));
	this.GameObjects.push(new Enemy(20,10));
	this.GameObjects.push(new Enemy(10,5));



}


function mainLoop() {

	Scene.Update();
	Scene.Draw();


	requestAnimationFrame(mainLoop);

}


function doKeyDown(e) {

			var code = e.keyCode;

			if (code == 87) { // w
				input.w = true;
			} else if(code == 83) { // s
				input.s = true;
			} else if(code == 65) { // a
				input.a = true;
			} else if(code == 68) { // d
				input.d = true;
			}
	}

	function doKeyRelease(e) {

		var code = e.keyCode;

			if (code == 87) { // w
				input.w = false;
			} else if(code == 83) { // s
				input.s = false;
			} else if(code == 65) { // a
				input.a = false;
			} else if(code == 68) { // d
				input.d = false;
			}



	}


	function lerp2(a,b,t) {

		//x axis
		var x = a + t * (b - a);

		return x;
	}

	//a and b are Vector2 objects
	function lerp(a,b,t) {

		//x axis
		var x = a.x + t * (b.x - a.x);

		//y axis
		var y = a.y + t * (b.y - a.y);

		var ret = new Vector2();
		ret.x = x;
		ret.y = y;

		return ret;

	}


	function getRandomArbitrary(min, max) {
  		return Math.random() * (max - min) + min;
	}



</script>


</html>